<div dir="rtl" style="text-align: justify;">

# گزارش تمرین گروهی ۱.۱

گروه ۳
-----

عرشیا اخوان <letmemakenewone@gmail.com>

محمدرضا عبدی <reza_abdi20@yahoo.com>

احمد سلیمی <ahsa9978@gmail.com> 

امیرمهدی نامجو <amirm137878@gmail.com> 

پاس‌دادن آرگومان
============
تغییرات نسبت به سند طراحی اولیه
----------------
- از داده ساختار 
args
 استفاده ای نشده است، 
 به دلیل اینکه بلافاصله پس از 
  tokenize
  کردن نام فایل,
  آن را مستقیما در پشته کاربر ذخیره کرده و نیازی به ساختن آرایه از رشته 
  tokenize
  شده نداشتیم.


داده‌ساختار‌ها
----------------
NULL

نحوه پیاده سازی
----------------
- ابتدا در تابع 
`start_process`،
رشته ورودی را
tokenize
کرده و به تابع
`push_args`
پاس می‌دهیم.
خروجی تابع
`push_args`
پیکانی به آرایه
`argv`
در پشته کاربر می‌باشد.
پس از انجام
stack alignment
مقدار
`argv`
و
`argc`
را به سر پشته هل می‌دهیم.

- تابع 
`push_args` 
مطابق جدول زیر، ابتدا
esp
را به مقدار لازم
پایین آورده، سپس با استفاده از
`memcpy`
رشتهٔ
`cmd`
را
-که
tokenize
شده است و در آن
به جای
space
ها
`NULL`
قرار داده شده است-
در پشته ذخیره می‌کنیم.
پس از آن به‌عنوان آخرین عضو
`argv`
مقدار
`NULL`
در پشته ذخیره می‌کنیم. در ادامه با استفاده از
`argv`
آدرس هر آرگومان را در پشته ذخیره می‌کنیم. سپس پوینتر به اولین
`arg`
را برمی‌گرداند.


<div dir="ltr">

|   Address  |      Name      |    Data    |     Type    |
|:----------:|:--------------:|:----------:|:-----------:|
| 0xbffffffc | argv[3][...]   | bar\0      | char[4]     |
| 0xbffffff8 | argv[2][...]   | foo\0      | char[4]     |
| 0xbffffff5 | argv[1][...]   | -l\0       | char[3]     |
| 0xbfffffed | argv[0][...]   | /bin/ls\0  | char[8]     |
| 0xbfffffec | stack-align    | 0          | uint8_t     |
| 0xbfffffe8 | argv[4]        | 0          | char *      |
| 0xbfffffe4 | argv[3]        | 0xbffffffc | char *      |
| 0xbfffffe0 | argv[2]        | 0xbffffff8 | char *      |
| 0xbfffffdc | argv[1]        | 0xbffffff5 | char *      |
| 0xbfffffd8 | argv[0]        | 0xbfffffed | char *      |
| 0xbfffffd4 | argv           | 0xbfffffd8 | char **     |
| 0xbfffffd0 | argc           | 4          | int         |
| 0xbfffffcc | return address | 0          | void (*) () |

</div>

فراخوانی‌های سیستمی
================
تغییرات نسبت به سند طراحی اولیه
----------------



داده‌ساختار‌ها
----------------

> ساختار مربوط به
file descriptor
 که برای کار با فایل استفاده شده است.

<div dir="ltr">

```c
/* In pintos/src/userprog/process.h */
typedef fid_t int;
struct file_descriptor
{
    fid_t fid;
    struct file *file;
    struct list_elem fd_elem;
};
```

</div>

> از این ساختار برای ورودی دادن
هنگام فراخوانی تابع
‍‍‍`start_process`
در تابع
`thread_create`
استفاده شده است.

<div dir="ltr">

```c
/* In pintos/src/threads/thread.h */
struct t_args
{
  char* fn;
  struct process_status* ps;
};
```

</div>

> موارد اضافه شده در ساختار thread، برای مدیریت پردازه‌ها و کار با فایل سیستم استفاده شده است.

<div dir="ltr">

```c
/* In pintos/src/threads/thread.h */
struct thread
  {
    ...
    /* status of process running by this thread */
    struct process_status *ps;

    /* list of all the child threads */
    struct list children;

    /* List of thread's file descriptors */
    struct list fd_list;
    /* id of next file id. Initially 2 */
    int next_fid;

    /* Thread's executable file */
    struct file* exec_file;
    ...
  };
```

</div>

> این ساختار اطلاعات 
`process`
 را نگه می‌دارد و برای کم حجم کردن ساختار 
`thread`
استفاده شده است.

<div dir="ltr">

```c
/* In pintos/src/userprog/process.c */
struct process_status
{
  /* tid of the curresponing process */
  pid_t pid;
  
  int exit_code;
  bool is_exited;

  /* wait sema
   * init to 0
   * used for handling wait between parent and child thread
   */
  struct semaphore ws; 

  /* initially 2
   * used for freeing resources 
   * number of alive threads referencing to this status  
   */
  int rc;
  
  /* strictly for changing value of rc */
  struct lock rc_lock;
  
  struct list_elem children_elem;
};
```

</div>

>  این قفل برای کار کردن با فایل سیستم تعبیه شده است.

<div dir="ltr">

```c
/* In pintos/src/filesys/filesys.h*/
struct lock fs_lock;
```

</div>

درستی‌سنجی ورودی‌های فراخوانی‌های سیستمی
------------
با توابع 
‍‍`validate_addr`
و
`is_valid_string`
هر کدام از آرگومان‌های پاس داده شده به فراخوانی سیستمی را درستی‌سنجی می‌کنیم.

نحوه پیاده‌سازی فراخوانی‌های سیستمی برای کنترل پردازه‌ها
------------

### 1. `exec`
تابع
`process_execute`
را با ورودی پاس داده شده به فراخوانی سیستمی، فراخوانی می‌کنیم.
تابع
`process_execute`
را همانند توضیحات ارائه شده در سند طراحی به گونه‌ای پیاده سازی کردیم که تا اتمام اجرای تابع
`load`
در 
`start_process`،
برای برگرداندن خروجی صبر نماید.

### 2. `exit`
متغیر
‍`exit_code`
 موجود در ساختار
`process_status`
را مقداردهی می‌کند و تابع
`thread_exit`
را صدا می‌زند.
درون تابع 
`process_exit`،
منابع تمام پردازه‌های فرزندی که خارج شده باشند
(`process_status::rc == 1`)
را آزاد می‌کند.

### 3. `halt`
تابع
`shutdown_power_off`
را فراخوانی می‌کند.

### 4. `wait`
این فراخوانی سیستمی، خروجی تابع
`process_wait`
 را بر می‌گرداند.
 برای پیاده‌‌سازی این تابع، ابتدا از لیست فرزند‌های این ریسه، فرزند با
 `tid`
 مورد نظر را پیدا می‌کنیم؛ اگر وجود نداشت، مقدار 1- را برمی‌گردانیم و در صورت وجود، روی سمافورِ
 `ws`
 آن، صبر می‌کنیم. 
 توجه نمایید که هر پردازه در هنگام خروج سمافور 
 `ws`
 خود را یک واحد بالا می‌برد.
 پس از اتمام صبر، 
 منابع گرفته شده توسط این پردازه را آزاد می‌کنیم.

### 5. `practice`
نخستین ورودی را یک عدد زیاد می‌کند.

نحوه پیاده سازی برای فراخوانی‌های سیستمی برای عملیات روی پرونده‌ها
------------

برای تضمین امن ریسه بودن کار با فایل، مجموعه‌ی جدیدی از توابع را در دو فایل 
filesys.c
و
file.c
تعریف کرده‌ایم که قبل از انجام عملیات مورد نظر، 
`fs_lock`
را اخذ کرده و پس از اتمام کار آن را رها می‌کند.

### `sys_create`, `sys_remove` و `sys_open`:
پس از درستی‌سنجی آدرس فایل، تابع متناسب با آن را در 
filesys.c
صدا می‌کند.

### `sys_close`:
پس از بستن فایل، آن را از لیست 
file descriptor
های ریسه حذف می‌کنیم.


### `sys_tell`, `sys_seek` و `sys_filesize`:
پس از بدست آوردن 
file descriptor
مورد نظر، تابع متناسب با آن را در 
file.c
صدا می‌زنیم.

### `sys_read`:
ابتدا بررسی می‌کنیم که 
‍`fid`
داده شده، برای این پردازه وجود داشته باشد و 
STDOUT_FILENO
نباشد.
تابع متناسب با آن را در 
file.c
صدا می‌زنیم.
اگر
`fid == STDIN_FILENO`
به جای تابع مذکور از 
`inputbuf`
استفاده می‌کنیم.

### `sys_write`:
ابتدا بررسی می‌کنیم که 
‍`fid`
داده شده، برای این پردازه وجود داشته باشد و 
STDOUT_FILEOUT
نباشد.
تابع متناسب با آن را در 
file.c
صدا می‌زنیم.
اگر
`fid == STDIN_FILEOUT`
به جای تابع مذکور از 
`putbuf`
استفاده می‌کنیم.

سوالات افزون بر طراحی
====================

- بیان کنید که هر فرد گروه دقیقا چه بخشی را انجام داد؟ آیا این کار را به صورت مناسب انجام دادید و چه کارهایی برای بهبود
عملکردتان می توانید انجام دهید.
  > همه کار ها به صورت جلسات ۴ نفره در
  vscode live share
   انجام شد و همه افراد گروه در تمام مسیر پیشرفت پروژه دخیل بوده‌اند.

- آیا کد شما مشکل بزرگی امنیتی در بخش حافظه دارد
(به طور خاص رشته‌ها در زبان C؟ )
memory leak
 و نحوه مدیریت ضعیف خطاها نیز بررسی خواهد شد.
  > کدهای اضافه شده توسط گروه هیچ مشکل بزرگ امنیتی جدیدی اضافه نکرده است.
  > در جواب سوال دوم نیز باید گفت که تست multi-oom را پاس کرده‌ایم. این تست نیاز به این دارد که فضاهای اضافی را که گرفته‌ایم تماماْ آزاد کرده باشیم. چون این تست سعی‌ می‌کند که ده بار، تعداد حداقل ۳۰ ترد را بسازد و انتظار دارد که هر دفعه بتواند دقیقا به اندازه دفعه قبلی کار را ادامه بدهد. بدین ترتیب اطمینان حاصل می‌کند که هیچ فضای اضافی از قبل آزاد نشده باقی نمانده باشد. کد ما می‌تواند تا ۶۰ ترد در هر بار اجرا را پشتیبانی کند. ضمن این که این تردها فایل هم باز می‌کنند و مشکلی پیش نمی‌آید. همچنین برای اجرای درست این تست باید امن ریسه بودن فایل‌ها هم تضمین بشود. همچنین در صورتی که یک کد page-fault بخورد باید قفل فایل سیستم را در صورتی که در اختیار دارد آزاد کند. کد ما همه این موارد را رعایت کرده است.
  
- آیا از یک Style Code واحد استفاده کردید؟ آیا style مورد استفاده توسط شما با pintos هم خوانی دارد؟(از نظر
فرورفتگی و نحوه نام گذاری)

  > بله

- آیا کد شما ساده و قابل درک است؟

  > بله، تلاش کرده‌ایم تا سطح سادگی و قابل فهم بودن کد در تمام کدبیس 
  pintos
  یکسان باشد.

- آیا کد پیچیده ای در بخشی از کدهای خود دارید؟ در صورت وجود آیا با قرار دادن توضیحات مناسب آن را قابل فهم کردید؟

  > خیر

- آیا کد Comment شده ای در کد نهایی خود دارید؟
آیا کدی دارید که کپی کرده باشید؟

  > خیر

- آیا الگوریتم های list linked را خودتان پیاده سازی کردید یا از پیاده سازی موجود استفاده کردید؟

  > خیر، از پیاده‌سازی موجود استفاده کردیم.

- آیا طول خط کدهای شما بیش از حد زیاد است؟ (۱۰۰ کاراکتر)

  > خیر

- آیا در git خودتان پرونده های binary حضور دارند؟(پرونده های binary و پرونده های log را commit نکنید!)
  > خیر

تست‌های افزون بر طراحی
====================

### `seek-and-tell`
در مستند تمرین خواسته شده بود که
`seek`
و
`tell`
پیاده‌سازی شوند؛ اما در تست‌ها هیچ کدام به صورت مستقیم تست نشده‌اند. در این تست روی یک فایل مواردی نوشته شده و سپس با
`seek`
و
`tell`
چک می‌کنیم که پوینتر درونی فایل به درستی جابه‌جا بشود.


### `pf-lr`
این تست مخفف
`Page Fault Lock Release`
است که به دلیل محدودیت اندازه فایل در
Pintos
نام آن را کوتاه کردیم.
این تست چک می‌کند که اگر یک پروسه در هنگام باز کردن فایل، به خطای
`page fault`
برخورد کرد
(مثلا نام فایل از استک کاربر بیرون زده بود)
پس از وقوع خطا، قفل فایل سیستم را رها کند.

</div>