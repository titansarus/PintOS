<div dir="rtl" style="text-align: justify;">

# گزارش تمرین گروهی ۲

گروه ۳
-----

عرشیا اخوان <letmemakenewone@gmail.com>

محمدرضا عبدی <reza_abdi20@yahoo.com>

احمد سلیمی <ahsa9978@gmail.com> 

امیرمهدی نامجو <amirm137878@gmail.com> 

ساعت زنگ‌دار
====================

در این بخش تغییر جدی نسبت به طراحی اولیه نداشتیم و تقریبا براساس همان توضیحات پیاده‌سازی را انجام دادیم.

به این شکل که یک مولفه به نام
`alarm_time`
به ریسه‌ها اضافه کردیم که زمان بیدار‌ شدن آن ها را مشخص می‌کند و یک لیست مرتب هم به نام
`sleepers`
برای ریسه‌های خوابیده داریم.

در تابع
`thread_sleep`
زمان مد نظر برای بیدار شدن را در 
`alarm_time`
مشخص کرده و در تابع
`thread_tick`
با جلو رفتن زمان، چک می‌کنیم که کدام ریسه‌ها را باید بیدار کنیم.

صرفا نیازی به
`sleepers_lock`
که در مستند اولیه نوشته بودیم، پیدا نکردیم و آن را در پیاده‌سازی استفاده نکردیم، زیرا با غیرفعال کردن وقفه‌ها عملا مشکل شرایط مسابقه‌ای پیش نمی‌آید.



زمان‌بند اولویت‌دار
====================

در مستند اولیه، برای طراحی
‍`conditional variable`
ها نکته خاصی در نظر نگرفته بودیم اما در پیاده‌سازی نیاز به تغییر آن‌ها هم پیدا کردیم تا لیست سمافورهای آن‌ها به ترتیب اولویت باشد. در نتیجه
به
`semaphore_elem`
مولفه
`priority`
را هم اضافه کردیم که  در تابع
`cond_wait`
مقداردهی می‌شود. (برابر با اولویت ریسه‌ای که روی آن متغیر شرطی صبر کرده)

شیوه کارکرد آن به این صورت است که هر ریسه‌ای که تلاش کند روی متغیر شرطی صبر کند، یک سمافور وارد لیست مربوطه که به صورت مرتب شده‌است می‌کند. در هنگامی که قصد بیدار کردن (سیگنال دادن) به یکی از ریسه‌‌های منتظر را داشته باشیم، براساس اولویت سمافور‌ نظیر آن‌ها اقدام می‌کنیم.

<div dir="ltr">

```c
struct semaphore_elem {
   ...
   int priority;
   ...
};
```
</div>

در مورد سوال پرسیده‌ شده در هنگام تحویل مستند اولیه، پیرامون حفظ وضعیت مرتب لیست در هنگام تغییر اولویت، روش کار ما همان طور که در هنگام تحویل توضیح دادیم، به این صورت است که ابتدا ریسه را از فهرست حذف کرده و دوباره به آن به صورت مرتب شده اضافه می‌کنیم که وضعیت مرتب لیست حفظ شود. این کار در تابع
`thread_set_priority_on_given`
انجام می‌شود:


<div dir="ltr">

```c
list_remove (&cur->elem);
list_insert_ordered (&ready_list, &cur->elem, thread_priority_comparator, NULL);
```
</div>


همچنین در زمان‌هایی نظیر ساخت ریسه، تغییر اولویت (با یا بدون اهدا)،
`sema_up`
که باعث ایجاد یا تغییر اولویت ریسه‌ها می‌شوند، اولویت ریسه سر لیست (بالاترین اولویت) را با ریسه فعلی مقایسه می‌کنیم و اگر اولویت ریسه فعلی کمتر بود، آن را
واگذار
می‌کنیم (yield).

در سایر موارد و الگوریتم‌های اصلی، مطابق با مستند اولیه پیاده‌سازی را انجام دادیم.



آزمایشگاه زمان‌بندی
====================
TODO:


سوالات افزون بر طراحی
====================

- بیان کنید که هر فرد گروه دقیقا چه بخشی را انجام داد؟ آیا این کار را به صورت مناسب انجام دادید و چه کارهایی برای بهبود
عملکردتان می توانید انجام دهید.
  > همه کار ها به صورت جلسات ۴ نفره در
  vscode live share
   انجام شد و همه افراد گروه در تمام مسیر پیشرفت پروژه دخیل بوده‌اند.

- آیا کد شما مشکل بزرگی امنیتی در بخش حافظه دارد
(به طور خاص رشته‌ها در زبان C؟ )
memory leak
 و نحوه مدیریت ضعیف خطاها نیز بررسی خواهد شد.
  > برای مدیریت خطا‌ها در جاهایی که لازم بوده ASSERT گذاشته شده است. همچنین در توابعی که تغییر ایجاد کردیم، ASSERT های قبلی پیاده‌سازی خود PINTOS را حفظ کردیم.
  > در مورد Memory leak تقریبا در هیچ کدام از توابعی که تغییر دادیم، نیازی به گرفتن حافظه از طریق روش‌هایی نظیر malloc نبوده است و همه حافظه‌ها، متغیرهای محلی توابع بوده‌اند که بعد از اتمام تابع از پشته خارج می‌شوند. در نتیجه Memory Leak نداریم.
  
- آیا از یک Style Code واحد استفاده کردید؟ آیا style مورد استفاده توسط شما با pintos هم خوانی دارد؟(از نظر
فرورفتگی و نحوه نام گذاری)

  > بله

- آیا کد شما ساده و قابل درک است؟

  > بله، تلاش کرده‌ایم تا سطح سادگی و قابل فهم بودن کد در تمام کدبیس 
  pintos
  یکسان باشد.

- آیا کد پیچیده ای در بخشی از کدهای خود دارید؟ در صورت وجود آیا با قرار دادن توضیحات مناسب آن را قابل فهم کردید؟

  > خیر

- آیا کد Comment شده ای در کد نهایی خود دارید؟
آیا کدی دارید که کپی کرده باشید؟

  > خیر

- آیا الگوریتم های list linked را خودتان پیاده سازی کردید یا از پیاده سازی موجود استفاده کردید؟

  > خیر، از پیاده‌سازی موجود استفاده کردیم.

- آیا طول خط کدهای شما بیش از حد زیاد است؟ (۱۰۰ کاراکتر)

  > خیر

- آیا در git خودتان پرونده های binary حضور دارند؟(پرونده های binary و پرونده های log را commit نکنید!)
  > خیر
</div>