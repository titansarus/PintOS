<div dir="rtl" style="text-align: justify;">

# تمرین گروهی ۱.۱ - مستند طراحی

گروه
-----
 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

عرشیا اخوان <letmemakenewone@gmail.com>

محمدرضا عبدی <reza_abdi20@yahoo.com>

احمد سلیمی <ahsa9978@gmail.com> 

امیرمهدی نامجو <amirm137878@gmail.com> 

مقدمات
----------
> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

پاس‌دادن آرگومان
============
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

- برای
initialize
کردن آرایهٔ
`argv`،
نیاز است ثابت زیر را در نظر بگیریم.

<div dir="ltr">

```c
#define MAX_ARGC    64
```

</div>

- از آنجایی که قرار است تابعی بنویسیم که دستور را
parse
کند، خروجی این تابع، استراکت زیر خواهدبود.

<div dir="ltr">

```c
struct args
{
    char *argv[MAX_ARGC];
    int argc;
};
```

</div>

- تعریف
space
به عنوان جداکنندهٔ ورودی‌ها:

<div dir="ltr">

```c
#define ARG_DELIM   " "
```

</div>

- تعریف یک ثابت برای محدود سازی طول رشتهٔ
`_file_name`

<div dir="ltr">

```c
#define MAX_FN_SIZE 8192
```

</div>


الگوریتم‌ها
------------
> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

- یک تابع می‌نویسیم که در آن با استفاده از تابع
`strtok_r`
مقادیر
`argv`
را می‌گیریم
و همزمان
`argc`
را محاسبه می‌کنیم.
`argv`
و
`argc`
در استراکت
`args`
قرار داده می‌شود و آن را بر می‌گرداند.

- ابتدا
esp
را به مقدار لازم
پایین آورده، سپس با استفاده از
`memcpy`
رشتهٔ
`file_name`
(که
tokenize
شده است و
به جای
space
ها
`NULL`
قرار داده شده است.)
را در پشته ذخیره می‌کنیم.
پس از آن بعنوان آخرین عضو
`argv`
مقدار
`NULL`
در پشته ذخیره می‌کنیم. در ادامه با استفاده از
`argv`
آدرس هر آرگومان را در پشته ذخیره می‌کنیم. سپس پوینتر به اولین
`arg`
را پس از آن، و مقدار
`argc`
را در پشته ذخیره می‌کنیم.
در نهایت، طبق مثال موجود در مستند انگلیسی پروژه، اگر
`argc = 4`
باشد، پشته بصورت زیر می‌باشد.


<div dir="ltr">

|   Address  |      Name      |    Data    |     Type    |
|:----------:|:--------------:|:----------:|:-----------:|
| 0xbffffffc | argv[3][...]   | bar\0      | char[4]     |
| 0xbffffff8 | argv[2][...]   | foo\0      | char[4]     |
| 0xbffffff5 | argv[1][...]   | -l\0       | char[3]     |
| 0xbfffffed | argv[0][...]   | /bin/ls\0  | char[8]     |
| 0xbfffffec | stack-align    | 0          | uint8_t     |
| 0xbfffffe8 | argv[4]        | 0          | char *      |
| 0xbfffffe4 | argv[3]        | 0xbffffffc | char *      |
| 0xbfffffe0 | argv[2]        | 0xbffffff8 | char *      |
| 0xbfffffdc | argv[1]        | 0xbffffff5 | char *      |
| 0xbfffffd8 | argv[0]        | 0xbfffffed | char *      |
| 0xbfffffd4 | argv           | 0xbfffffd8 | char **     |
| 0xbfffffd0 | argc           | 4          | int         |
| 0xbfffffcc | return address | 0          | void (*) () |

</div>


- برای جلوگیری از
stack overflow،
اگر طول رشتهٔ
`_file_name`
بزرگتر از ثابت
`MAX_FN_SIZE`
باشد، برنامه را اجرا نمی‌کنیم.



منطق طراحی
-----------------
> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

چون
Thread Safe
است. بدین معنا که ریسه‌های مختلف، می‌توانند همزمان از این تابع استفاده کنند، در حالی که در
`strtok`،
مقدار
`saveptr`
بصورت
`static`
تعریف شده ‌است
و یعنی بصورت همزمان نمی‌توان دو رشتهٔ مختلف را
tokenize
کرد.

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

1. پیچیدگی پیاده‌سازی و زمانی کرنل برای پردازش دستور کمتر می‌شود.

1. پیش از تحویل دستور به کرنل،
shell
می‌تواند بررسی کند که آیا فایل داده‌شده موجود است و دسترسی اجرا دارد یا نه.

1. در حالتی که به طور مثال از
pipe
در دستور استفاده شده باشد، پردازش مربوط به آن باید در کرنل انجام می‌شد، اما در صورت هندل شدن این قضیه در
shell،
جداسازی دستورات توسط
shell
انجام می‌شد و این پیچیدگی به کرنل منتقل نمی‌شد.

فراخوانی‌های سیستمی
================
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

<div dir="ltr">



```c
/* In pintos/src/threads/thread.h */
#ifdef USERPROG
/* used for holding thread status */
struct thread_status
{
  /* pid of the curresponing process */
  pid_t pid;
  
  int exit_code;
  
  /* 
   * wait sema
   * init to 0
   * used for handling wait between parent and child thread
   */
  struct semaphore ws; 
  
  /* 
   * initially 2
   * used for freeing resources 
   * number of alive threads referencing to this status  
   */
  int rc;
  
  /* strictly for changing value of rc */
  struct lock rc_lock;
  
  /* If parent already waited on this child once!  */
  bool already_waited;

  struct list_elem children_elem;
};
#endif
```
</div>

<div dir="ltr">


```c
/* In pintos/src/threads/thread.h */
#define MAX_FILE_DESCRIPTOR 1024
```

```c
/* In pintos/src/userprog/syscall.c */
static struct lock fs_lock; // so that only one thread at the time accesses the filesystem
```

```c
/* In pintos/src/userprog/thread.h */
struct FD { // file descriptor mapping
  int fid;
  struct file * fp;
}
```

```c
/* In pintos/src/threads/thread.h */
struct thread
{
  ...
#ifdef USERPROG
  ...
  /* status of process running by this thread */
  struct thread_status *status;

  /* list of all the child threads */
  struct list children_status;

  /* list of all file descriptors */
  struct FD *fd[MAX_FILE_DESCRIPTOR];
#endif
  ...
};
```
</div>

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟


در هر
`thread`
، یک آرایه از
`file descriptor`
ها ذخیره می‌کنیم. این آرایه از نوع
`*FD`
است و اندازه آن برابر
`MAX_FILE_DESCRIPTOR`
است که آن را برابر ۱۰۲۴ تعریف کرده‌ایم.

در هر
`FD`
شماره
`file descriptor`
 آن و فایلی
(`*file`)
 که به آن نگاشت شده است را ذخیره کرده ایم.

بدین ترتیب، توصیف کننده‌‌ها در هر پردازه یکتا هستند. ولی در سیستم عامل یکتا نیستند. یعنی یک
`file descriptor`
می‌تواند با اعداد مختلف در پردازه‌های گوناگون باز شده باشد و در نتیجه شماره‌ آن برای هرکدام متفاوت خواهد بود. 


الگوریتم‌ها
------------
> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.



ابتدا تعدادی اعتبارسنجی روی پوینترها انجام می‌دهیم.

- خواندن:

در صورتی که در حالت خواندن بودیم، چک می‌کنیم که فایل داده شده
`STDOUT_FILENO`
نباشد. چون قصد خواندن داریم. اگر این اتفاق افتاد خطا بر می‌گردانیم.

در غیر این صورت، سعی می‌کنیم قفل
`fs_lock`
را بگیریم.
اگر موفق بودیم، که عملیات خواندن را انجام می‌دهیم و در نهایت قفل را آزاد کرده و مقدار 0 را بر می‌گردانیم.

- نوشتن:

در صورتی که در حالت نوشتن  باشیم، چک می‌کنیم که
‍`STDIN_FILENO`
نباشد چون قصد نوشتن داریم. اگر این اتفاق افتاد خطا (1-) برمی‌گردانیم.

در غیر این صورت سعی می‌کنیم قفل
`fs_lock`
را بگیریم.
اگر موفق بودیم، عملیات نوشتن را انجام می‌دهیم و در نهایت قفل را آزاد کرده و مقدار 0 را بر می‌گردانیم.


> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟



- صفحه کامل

در حالتی که صفحه کامل بخواهیم، در بهترین حالت این است که دقیقا کل یک
صفحه داده مدنظر ما است و با یک بار فراخوانی
`pagedir_get_page`
به داده می رسیم. پس کمترین حالت جواب یک است.

در بیش‌ترین حالت دو شکل را می‌توانیم مد نظر قرار دهیم. اگر همه داده‌ها پشت سر‌هم ذخیره شده باشند، مثلا از اواسط یک صفحه داده ما شروع شده باشد و تا
اواسط صفحه بعد رفته باشد، با دو بار فراخوانی
`pagedir_get_page`
به نتیجه می‌رسیم. اگر فرض کنیم داده‌های ما پشت هم ذخیره نشده باشند، در بدترین حالت هر کدام در یک صفحه مجزا هستند و نیاز به
۴۰۹۶ بار فراخوانی
`pagedir_get_page`
داریم.

- صفحه دوبایتی

در این حالت هم مشابه قسمت قبل کمترین حالت یک است.

در بیش‌ترین حالت، چه داده‌ها پشت سرهم باشند و چه نباشند جواب ۲ است. به این شکل که اگر داده‌ها پشت هم نباشند و در دو صفحه مجزا باشند، دو فراخوانی
`pagedir_get_page`
نیاز است. اگر پشت هم باشند اما مثلا ابتدا آن دقیقا در انتهای یک صفحه باشد و انتهای آن دقیقا در ابتدای صفحه بعد باشد، باز هم نیاز به دوبار فراخوانی
`pagedir_get_page`
داریم. پس جواب بیشینه در این حالت ۲ است.

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

هر بار که فراخوانی سامانه‌ای 
`wait`
را انجام می‌دهیم، پس از اعتبار سنجی لازم برای ورودی‌ها، از استراکت ریسه، استراکت
`‍thread_status`
مرتبط با
`pid`
ای که می‌خواهیم روی آن
`wait`
کنیم، پیدا کرده و بررسی می‌کنیم که اگر
`already_waited`
برابر با
`TRUE`
بود، مقدار 1- را برگردانده و در غیر این صورت ابتدا مقدار
`rc`
را بررسی می‌کنیم و اگر برابر با 1 بود، منابع ریسه‌ی کذا را آزاد کرده و کد بازگشت آن را خروجی می‌دهیم و در غیر این صورت با استفاده از سمافور 
`ws`
منتظر پایان یافتن ریسه‌ی کذا می‌مانیم.
سپس مراحل بالا را برای آزاد کردن منابع تکرار می‌کنیم.


> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

1. یک تابع
`validator`
تعریف می‌کنیم که بررسی می‌کند، اشاره‌گر داده شده در
‍`user stack`
قرار دارد و مقدار آن پوچ نباشد. همچنین بررسی می‌کند که آیا بازه‌ای از پشته که نیاز به دسترسی به آن را داریم، در شرایط بالا صدق کند.

1. همانطور که در پاسخ سوال دوم بخش همگام‌سازی شرح داده شده است، با فراخوانی تابع 
`thread_exit`
مراحل لازم برای آزاد سازی منابع را انجام می‌دهیم.


همگام‌سازی
---------------
> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

با استفاده از  سمافور 
`ws`
در تابع 
`process_execute`
بعد از ساخت موفقیت آمیز یک ریسه نو، تابع
`sema_down`
را صدا زده و سپس در
`process_start`
بعد از فراخوانی و اجرای تابع  
`load`
تابع
`sema_up`
را برای 
`ws`
صدا زده و بدین ترتیب مطمئن می‌شویم که فراخوانی سیستمی 
`exec`
بعد از مشخص شدن نتیجه بارگذاری، 
`exit code` 
مناسب را برمی‌گرداند.

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

برای حل این مشکل از دو مقدار 
`rc`
و
`rc_lock`
استفاده می‌کنیم. به این صورت که هرگاه که یکی از پردازه های 
`P`
یا
`C`
به صورت عادی یا به دلیل بروز
`exception`
پایان یافت, ابتدا تلاش می‌کند تا 
`rc_lock`
را بگیرد و سپس مقدار
`rc`
را یک واحد کم کند و اگر هنگام پایان پردازه مقدار
`rc`
صفر بود, منابع مربوطه را آزاد می‌نماید.

منطق طراحی
-----------------
> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

در مستند انگلیسی 
warmup
 در صفحه
 ۱۶ 
 و
 ۱۷
 دو روش گفته شده بود. ما روش اول را انتخاب کردیم.
 زیرا
با وجود اینکه روش انتخابی ما موجب کاهش سرعت اندکی در کرنل می‌شود، پیاده سازی ساده‌تری دارد و بهتر می‌توان  به هنگام رسیدگی به خطا، از آزاد شدن تمامی منابع کاربر اطمینان حاصل کرد.

در روش دوم که در مستند انگلیسی  گفته شده است، پیشنهاد شده از دو تابع به نام‌های 
`get_user`
و
`put_user`
استفاده کنیم که  از پیاده سازی دقیق آن مطمئن نبودیم و در نتیجه ترجیح دادیم که از این روش استفاده نکنیم.

> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

 - نقاط قوت:
   - شخصی سازی file descriptor ها برای هر thread
   - سرعت بالا در آزاد کردن file descriptor ها به هنگام پایان کار thread
   - راحتی دسترسی به file descriptor ها
 - نقاط ضعف:
   - محدود بودن تعداد فایل های باز همزمان
   - سنگین شدن استراکت thread 
> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

تغییر ندادیم :)


سوالات افزون بر طراحی
===========
> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.


 <div dir="ltr">

 - `sc-bad-sp.c`



 ```c
void
test_main (void)
{
  asm volatile ("movl $.-(64*1024*1024), %esp; int $0x30");
  fail ("should have called exit(-1)");
}
```
</div>

در دستور‌های اسمبلی، علامت دلار به معنی
immediate
است. نقطه نشانگر
`PC`
است. در این جا سعی می‌کند یک مقدار نامعتبر را به درون ثبات اشاره‌گر پشته
`esp`
بریزد و این کار می کند. در نتیجه با فراخوانی وقفه، که باید با خطا رو به رو شده و
با مقدار 
`1-`
خارج بشود.


> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

<div dir="ltr">

- `sc-bad-arg.c`

```c
void
test_main (void)
{
  asm volatile ("movl $0xbffffffc, %%esp; movl %0, (%%esp); int $0x30"
                : : "i" (SYS_EXIT));
  fail ("should have called exit(-1)");
}
```
</div>

در این جا ابتدا استک را در یک نقطه خلی مرزی یعنی چهار بایت پایین تر از 
`PHYS_BASE`
که 
`0xc0000000`
است، قرار می‌دهد. سپس سعی‌ می‌کند مقدار صفر را در آن بنویسد. 
همچنین در این جا سینتکس گسترش یافته
`gcc`
استفاده شده و عبارت پس از 
`:`
دوم، سعی می‌کند که به عنوان مقدار ورودی روی بالای استک نوشته شود. با توجه به این که مقدار صفر در خانه
`$0xbffffffc`
تا
`$0xc0000000`
قرار گرفته است، مقدار
‍`SYS_EXIT`
در نقطه‌ای بالاتر از 
`$0xc0000000`
سعی‌میکند قرار بگیرد که بالاتر از فضای مجاز آدرس کاربر است و در نتیجه باید با خطای
`1-`
متوقف بشود.

سوالات نظرخواهی
==============
پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

آسان, آسان, آسان.
وقت در حد اپسیلون.

هنوز فایل سیستم تدریس نشده :))

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

سیستم عامل که نه ولی ۸۰۸۶ چرا!

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟


**این درس را حذف کنید که موجب آسایش خود و ما می‌شود :)**

به جوهای موجود مبنی بر این که درس به طور عجیبی سخت است و حذف کنید و فلان، گوش ندهید. درس سخت نیست. ابهام دارد :)))

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

لطفا واژه ها را برگردان نکنید.

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.

چرا سوال ها اینقدر ابهام دارد؟

</div>