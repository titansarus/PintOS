<div dir="rtl" style="text-align: justify;">

تمرین گروهی ۳ - مستند طراحی
======================

گروه
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

عرشیا اخوان <letmemakenewone@gmail.com>

محمدرضا عبدی <reza_abdi20@yahoo.com>

احمد سلیمی <ahsa9978@gmail.com> 

امیرمهدی نامجو <amirm137878@gmail.com> 

مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.


<div dir="ltr">

```c
#define BUFFER_CACHE_SIZE 64

struct cache_block {
    block_sector_t sector;
    char data[BLOCK_SECTOR_SIZE];
    int dirty;
    int valid;
    struct lock c_lock;

#ifdef SHAKH
    struct condition ok_to_read;
    struct condition ok_to_write;
    int waiting_w;
    int waiting_r;
    int available_w;
    int available_r;
#endif
    struct list_elem elem;
}
struct cache_block cache_blocks[BUFFER_CACHE_SIZE];
struct list cache;
struct lock cache_modify_lock;
```
</div>

الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

در ابتدا تمام بلاک های 
`cache_blocks`
را درون لیست کش قرار می‌دهیم، از این پس هر بار که یک بلاک از کش را می‌خوانیم یا روی آن می‌نویسیم، آن بلاک را به سر لیست منتقل می‌کنیم. با استفاده از این روش می‌توانیم مطمئن شویم که آخرین بلاک لیست، بلاکی است که دیرتر از همه استفاده شده است و در صورت نیاز برای جایگزینی بلاک، از این بلاک استفاده می‌کنیم. (LRU) 
از آنجایی که سایز لیست نسبتا کوچک است، الگوریتم LRU 
به خوبی کار می‌کند.

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

در هر عملیات خواندن و نوشتن از دیسک به جای اینکه تنها داده مورد نظر را بخوانیم، یک بلاک کامل از دیسک می‌خوانیم تا اگر بعدها به داده‌های بعدی نیاز شد، بتوانیم این نیاز را از طریق کش برطرف کنیم.

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

هر بلاک به صورت مجزا، برای خود یک قفل دارد که برای هر عملیات خواندن یا نوشتن، ابتدا تلاش می‌کند تا قفل را از آن خود کند و با این روش از دخالت دیگر ریسه‌ها هنگام عملیات جلوگیری می‌کند.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

برای هر گونه دسترسی به بلاک باید ابتدا قفل آن را دریافت کرد.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

read-ahead:
  هنگام مشاهده فیلم، معمولا چندین ثانیه قبل و بعد از جایی که کاربر مشاهده می‌کند، در کش وجود دارد. بنابراین فریم‌های فیلم بدون تاخیر قابل ملاحظه‌ای لود می‌شوند. و تجربه نرم و روانی به کاربر منتقل می‌شود.

write-back: 
هنگامی که برق سیستم به صورت ناگهانی قطع می‌شود تمام  بلاک های 
‍`dirty`  
روی حافظه نهان
پاک شده و  تمام  دیتا های نوشته شده از دست می‌رود
ولی عملیات 
‍‍`write-back`
این امکان را به ما می‌دهد تا به صورت موازی دیتاهای روی کش را بر روی دیسک ذخیره کنیم و درصد دیتای ازدست رفته را کاهش دهیم.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

<div dir="ltr">

```c
/* inode.c */
#define DIRECT_BLK_CNT 123
#define IND_BLK_CNT 128
#define DBL_IND_BLK_CNT 128

struct inode_disk {
  ...
  block_sector_t db[DIRECT_BLK_CNT];    // size: (123)*4
  block_sector_t ib;                    // size: 4
  block_sector_t dib;                   // size: 4
  is_dir        // desribed is mission 3   size: 4
  ...

/* Removed
 block_sector_t start;                First data sector. 
 uint32_t unused[125];                Not used.
*/

};

struct indirect_block {
  block_sector_t blocks[IND_BLK_CNT];
};

struct double_indirect_block {
  block_sector_t indirect_blocks[DBL_IND_BLK_CNT];
};

/* In-memory inode. */
struct inode
  {
    ...
    struct lock iـlock;             /* Inode lock. */
    ...
  };


static bool inode_allocate (struct inode_disk *inode_disk, off_t length);
static void inode_free (struct inode *inode);
```
</div>

 سه فیلد 
`db`، 
`ib`،
`dib`
برای پشتیبانی از طبقه‌بندی چند سطحه به داده ساختار 
`inode_disk`
 افزودیم.
(توضیحات بیشتر در منطق طراحی)

فیلد‌های افزوده شده در کل 504 بایت فضا اشغال می‌کنند که برای رعایت  محدودیت 512 بایتی 
`BLOCK_SECTOR_SIZE`
فیلدهای 
`unused`
و
`start`
را حذف کرده‌ایم.

 دو تابع 
`inode_allocate`
و
`inode_free`
را برای ساخت، گسترش و حذف 
`inode`
پیاده‌سازی می‌کنیم.
فیلد
`i_lock`
را به داده ساختار
`inode`
برای مدیریت شرایط مسابقه اضافه کرده‌ایم.


>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

<div dir="ltr">
512 * (123 + 128 + 128 * 128) = 512 * 16636 = 8517632 ≃ 8.5 MB
</div>


همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

تمامی توابعی که با 
`inode`
ها کار می‌کنند، ابتدا می‌بایست قفل 
`i_lock`
را گرفته و سپس عملیات خود را انجام دهند، لذا هیچ‌گونه حالت مسابقه‌ای پیش نخواهد آمد.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

تمامی توابعی که با 
`inode`
ها کار می‌کنند، ابتدا می‌بایست قفل 
`i_lock`
را گرفته و سپس عملیات خود را انجام دهند، فلذا ریسه 
`A`
یا به ته فایل رسیده و اعلام 
`EOF` 
می‌کند و پس از آن ریسه 
`B`
شروع به نوشتن در فایل می‌کند
و یا
ابتدا ریسه 
‍`B`
تمام داده‌ی مورد نظر خود را در پرونده نوشته و پس از آزاد سازی قفل ریسه 
`A`
شروع به خواندن از پرونده می‌کند.



>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

از آنجایی که فرآیند دستیابی به قفل هر 
`inode`
تصادفی است، عدالت بین ریسه‌های نویسنده و خواننده رعایت می‌شود.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

بله، ما در طراحی خود از منطق 
`ext`
الهام گرفته و همانطور که در 
`struct inode_disk`
قابل مشاهده است، تعداد 
‍`DIRECT_BLK_CNT=124`
اشاره‌گر مستقیم داریم و تعداد 
`IND_BLK_CNT=128`
اشاره‌گر غیر مستقیم داریم و درنهایت 
`DBL_IND_BLK_CNT=128`
اشاره‌گر غیرمستقیم با عمق دو داشته.
که در مجموع توانایی مدیریت کردن 
8.5 مگابایت
را داریم.
همانند بحث‌های مطرح شده در کلاس، تعداد زیادی از فایل‌ها که حجم کمی نیز دارند، با همان 124 اشاره‌گر مستقیم مدیریت شده و در نتیجه زمان دسترسی پایینی دارند. تعداد کمی از فایل‌ها که حجم بالایی دارند، با اشاره‌گر ‌های غیر مستقیم مدیریت شده که زمان دسترسی به آنها کمی بیشتر می‌کند، اما با توجه به قانون Zipf حجم فایل‌ها، میانگین زمان دسترسی همچنان پایین خواهد بود.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

<div dir="ltr">

```c
struct thread {
  ...
  struct dir *working_dir;
  ...
};

struct inode_disk {
  ...
  bool isdir;
  ...
};

bool
dir_lookup (const struct dir *dir, const char *name,struct inode **inode)

bool 
dir_create (block_sector_t sector, size_t entry_cnt)


```
</div>

در ساختار 
`thread`
یک اشاره‌گر به پوشه محل کار ریسه اضافه کرده‌ایم.
در ساختار 
`inode_disk`
نیز یک
‍`isdir`
اضافه می‌کنیم.
ضمنا تابع
`()lookup_dir` 
را به‌ گونه‌ای تغییر می‌دهیم که بتواند به پوشه پدر دسترسی داشته باشد.
`()dir_create`
را تغییر می‌دهیم به گونه‌ای که پوشه پدر را در اولین خانه 
inode
ذخیره کند.

الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

از آنجایی که
sector
ریشه در
pintos
وجود دارد، برای طی کردن مسیر 
absolute
با استفاده از 
`ROOT_DIR_SECTOR`
و مسیر
absolute،
تابع 
`lookup_dir`
را صدا می‌زنیم تا به صورت تو در تو 
`inode` 
متناظر با آن را پیدا کند.
برای طی کردن مسیر
relative
نیز تنها کافی است از 
`working_dir‍`
و مسیر
relative
استفاده کنیم.

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

از آنجایی که هر پوشه یک 
`inode`
است و هر 
`inode`
یک قفل دارد، می‌توان با گرفتن قفل آن 
`inode`،
از شرایط مسابقه جلوگیری کرد.
پاک کردن تمامی پوشه‌ها برای تمامی ریسه‌ها امکان‌پذیر است. اگر ریسه‌ای درخواست دسترسی به پوشه‌ای کند که حذف شده است، با خطا مواجه می‌شود.
اگر ریسه‌ای پرونده‌ای را باز داشته باشد که ریسه دیگر آن را حذف کرده است و بخواهد به آن دسترسی پیدا کند، باعث ایجاد 
`kernel PANIC`
شده و در نهایت پردازه آن ریسه 
`kill`
می‌شود.

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

از آنجایی که اصول یک طراحی مناسب در سیستم‌عامل سادگی، تمامیت، بهره‌وری و استفاده از منابع موجود در حد امکان است، تنها با اضافه کردن چند فیلد جزئی در داده ساختار‌های 
pintos
و تغییر چند تابع محدود، به صورت کارا روی درخت پوشه‌ها حرکت کرده و عملیات‌های  مربوطه را پشتیبانی کنیم. به همین جهت
` struct dir *working_dir`
را به داده‌ساختار ریسه اضافه کردیم تا پوشه محل کار هر ریسه مشخص باشد.



افزون بر طراحی
=================

>>  برای این پروژه ۲ ویژگی اختیاری درباره حافظه نهان بافر    وجود دارد: 
>>`write-behind`
>>یا 
>>`read-ahead`
>> .یک حافظه نهان بافر با
>>`write-behind`
>> به صورت متناوب بلوک های تغییر داده شده را در بلوک های فایل سیستم دستگاه می نویسد تا در صورت قطعی
>> برق سیستم اطلاعات زیادی از دست ندهد. بدون این ویژگی حافظه نهان 
>> `back-write`
>> فقط زمانی که یک داده کثیف شده و
>> در حال خارج شدن از حافظه نهان است یا سیستم در حال خاموش شدن است داده را در دیسک می نویسد. یک حافظه نهان با
>> `read-ahead`
>>پیش بینی می کند که چه داده ای را سیستم نیاز خواهد داشت و در پس زمینه داده را واکشی می کند و می تواند
>>به خوبی کارایی را در خواندن فایل های متوالی یا خواندن فایل ها با الگو هایی با قابلیت پیش بینی آسان افزایش دهد.درباره یک
>>استراتژی ممکن برای پیاده سازی این دو ویژگی بحث کنید. شما باید به این سوال جدا از این که قصد پیاده سازی این ویژگی ها را
>>دارید یا خیر پاسخ دهید.

#### write-behind
در آغاز کار هسته سیستم عامل
pint
یک ریسه خواهیم ساخت که وظیفه آن نوشتن تمام 
`block` 
های کثیف در 
`disk`
و تمیز کردن آن 
`block` 
ها 
`(dirty=0)`
و سپس 
`sleep`
کردن برای زمان مشخص باشد. سپس این ریسه را به لیست ریسه‌ها اضافه می‌کنیم تا خود هسته امور یه 
`scheduling` 
و 
`block/unblock`
کردن ریسه مورد نظر را بر عهده بگیرد.

#### read-ahead:

 هر بار که یک عملیات خواندن روی دیسک انجام می‌دهیم، روی بافر کش حرکت کرده و  تعداد 
 `sector`
 های واکشی شده در بافر کش که دقیقا پشت 
 `sector`
 مورد نظر هستند، بدست می‌آوریم. حال هنگام خواندن از دیسک علاوه بر خواندن
 `sector`
 مورد نظر، به تعداد دو برابر عدد بدست آمده منهای دو نیز
 `sector`
 جدید می‌خوانیم. دقت کنید در 
 pintos
 هر بلاک یک 
 `sector`
 در دیسک دارد.

### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟

</div>
